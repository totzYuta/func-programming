# ラムダ計算 Lambda Caliculus

## ラムダ計算とは

関数の評価（evaluation）と適用（application）でモデル化


### ラムダ記法 lambda notation

ラムダ記法(λ notation)は関数の表記の一種で，関数そのものと，その関数に引数を与えた計算結果（値）の区別ができるようにしたもの！

e.g.

```
f(x) = ax^2 + bx + c
```

これをラムダ記法で書くと...

```
関数f: f = λx. ax^2 + bx + c
値f(x): (λx. ax^2 + bx + c) x 
```

値の最後が，代入する値を示している．上の例だと`x`だけど，この`x`は例えば`1`とか`2`とかにもなるわけだ．

λ式は，高階関数を表現する時に力を発揮する．

最初に与えられた関数に依らず，もっと一般的に関数の世界に内在する性質を考察するために，λ記法を一般化したのがλ式なのである！


### λ式 lambda term

定義は以下のようになっている．

1. 変数 x0, x1, ...はλ式
2. Mがλ式でxが変数のとき(λx.M)はλ式 ... 「ラムダ抽象(lambda abstraction)->関数そのものを表す」といこと
3. MとNがλ式のとき(MN)はλ式 ... 適用(application) -> 上の例の値f(x)のこと．xに当てはめる＝適用するから

BNFで書くと...

```
<expr> = <identifier>
<expr> = λ<identifier>.<expr>
<expr> = (<expr><expr>)
```

って感じになる．

まとめると...


**全てがλ式！！！！！！**

ってこと！！！！

(意味がわからん...)

- e.g. xにfを2回適用するλ式

```
(λx. (f(fx)))
```


変数の束縛 binding, scoping

```
λx. x
```

最初の`x`は引数, 次の`x`を束縛している．後ろの`x`を**束縛変数 bound variable**という．逆に`λx.x+y`のyみたいに束縛されてない変数は，自由変数と呼ばれる．

(α変換なんてのもある...僕はわかりません...)


```
( λx. (x+1) )5
=> 6
```

スコープがある．一番内側の束縛が有効

```
λx. (λx.x) ≡  λy. (λx.x) !≡  λx. (λy.x)
```



### β-簡約 beta reduction

定義

```
1. (λx.M)N ---> M[x:=N]  (* <- Mの中のxの部分をNとしたもの *)
            β
2. M -> N ならば，λx.M -> λx.N, MP -> NP, PM -> PN 
     β                 β           β         β 
```


e.g.

```
( λx.(x+1) )5 ---> 6
               β
```

e.g. 

1. I = λx.x (高等関数)のとき

```
IM ≡ (λx.x)M -> M
             β
```

2. K ≡ λxy.x のとき

```
KM ≡ ( (λxy.x)M )N -> (λy.M)N -> M
                   β          β
```

λに近いやつ，手前のやつから代入していく．

3. S ≡ λxyz. xz(yz) のとき

```
SPQR ≡ (λxyz.xz(yz))PQR
    -> (λyz.Pz(yz))QR
    -> (λz.Pz(Qz))R
    -> PR(QR)
```


面白い性質

```
SKK -> I
```

再びK ≡ λxy.xのとき，

```
SKK ≡ (λxyz.xz(yz))KK
    -> λz.Kz(Kz)
    ≡ λz.(λxy.x)z.((λxy.x)z)
    -> λz.(λy.z)(λy.z)
    -> λz.z ≡ I
```
  
SKでIの代わりができる！

SKKで高級関数に！


λ式は，名前を持っていないので，自分自身のことを参照することができない． -> ということは再帰が書けない！？


4. λ式Mに対して

M' = M" M", M" = λx.M(xx) とおくと

```
M' ≡ ((λx.M(xx)))M" -> M(M" M") ≡ MM'  <- 不動点
```

ってやったらいっこのM'からMがくっついたM'が出てきた！
